# -*- coding: utf-8 -*-
# MLC (Machine Learning Control): A genetic algorithm library to solve chaotic problems
# Copyright (C) 2015-2017, Thomas Duriez (thomas.duriez@gmail.com)
# Copyright (C) 2015, Adrian Durán (adrianmdu@gmail.com)
# Copyright (C) 2015-2017, Ezequiel Torres Feyuk (ezequiel.torresfeyuk@gmail.com)
# Copyright (C) 2016-2017, Marco Germano Zbrun (marco.germano@intraway.com)
# Copyright (C) 2016-2017, Raúl Lopez Skuba (raulopez0@gmail.com)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>

# -*- coding: utf-8 -*-

import math
import numpy as np
import os
import sys
import threading
import traceback
sys.path.append(os.path.abspath(".") + "/../..")

from MLC.Application import MLC_CALLBACKS
from MLC.GUI.Autogenerated.autogenerated import Ui_ExperimentInProgressWindow
from MLC.GUI.Experiment.QtCharts.QtChartWrapper import QtChartWrapper
from MLC.arduino.protocol import ProtocolIOException, ProtocolSetupException
from MLC.Log.log import get_gui_logger

from PyQt5.QtCore import pyqtSignal
from PyQt5.QtCore import QPointF
from PyQt5.QtGui import QFont
from PyQt5.QtCore import Qt
from PyQt5.QtWidgets import QMainWindow
from PyQt5.QtWidgets import QMessageBox

from threading import Thread
from threading import Condition
logger = get_gui_logger()


class ThreadCancelException(Exception):

    def __init__(self):
        Exception.__init__(self, "[EXPERIMENT_IN_PROGRESS] [THREAD_CANCELLED] - "
                                 "Thread was cancelled by the user")


class ExperimentCondition():

    def __init__(self):
        self._condition = Condition()
        self._experiment_stopped = False
        self._experiment_cancelled = False
        self._experiment_failure = False

    def stop_experiment(self):
        self._condition.acquire()
        self._experiment_stopped = True
        self._condition.release()

    def continue_experiment(self):
        self._condition.acquire()
        self._experiment_stopped = False
        self._condition.notify()
        self._condition.release()

    def cancel_experiment(self):
        self._condition.acquire()
        self._experiment_stopped = False
        self._experiment_cancelled = True
        self._condition.notify()
        self._condition.release()

    def fail_experiment(self):
        self._condition.acquire()
        self._experiment_failure = True
        self._condition.notify()
        self._condition.release()

    def wait_if_experiment_stopped(self):
        had_to_wait = False
        self._condition.acquire()
        if self._experiment_stopped:
            self._condition.wait()
            had_to_wait = True
        self._condition.release()
        return had_to_wait

    def experiment_cancelled(self):
        cancelled = None
        self._condition.acquire()
        cancelled = self._experiment_cancelled
        self._condition.release()
        return cancelled

    def experiment_failure(self):
        self._condition.acquire()
        failure = self._experiment_failure
        self._condition.release()
        return failure


class ExperimentInProgressWindow(QMainWindow):
    indiv_evaluated = pyqtSignal([int, int, int, float])
    new_generation = pyqtSignal()
    simulation_finished = pyqtSignal()
    board_setup_failure = pyqtSignal([str])
    board_io_error = pyqtSignal([str])

    def __init__(self, parent, parent_signal, chart_params, from_gen, to_gen):
        QMainWindow.__init__(self, parent)
        self._autogenerated_object = Ui_ExperimentInProgressWindow()
        self._autogenerated_object.setupUi(self)

        # Set Dialog first attributes
        self._autogenerated_object.gen_progress_bar.setValue(0)
        self._autogenerated_object.indiv_progress_bar.setValue(0)
        self._autogenerated_object.indiv_label.setText("Individual 0/0")
        self._autogenerated_object.gen_label.setText("Generation 0/0")

        self._log_prefix = '[EXPERIMENT_IN_PROGRESS]'
        self.indiv_evaluated.connect(self._update_dialog)
        self.simulation_finished.connect(self._simulation_finished)
        self.new_generation.connect(self._create_new_chart)
        self.board_setup_failure.connect(self._board_setup_failure)
        self.board_io_error.connect(self._board_io_error)

        # Signal to be emited when the experiment finished
        self._parent_signal = parent_signal

        # Original from and to generation
        self._from_gen = from_gen + 1
        self._to_gen = to_gen

        # Individuals Graph data
        self._chart_params = chart_params
        self._current_generation = from_gen

        # Condition variable used to check when the experiment has been stopped or cancelled
        self._experiment_condition = ExperimentCondition()
        self._simulation_has_finished = False

    def closeEvent(self, event):
        logger.debug('[EXPERIMENT_IN_PROGRESS] [CLOSE_DIALOG] - Executing overriden closeEvent function')
        if not self._simulation_has_finished:
            if not self.on_cancel_button_clicked():
                event.ignore()

    def add_experiment_data(self, amount_gens, indivs_per_gen):
        self._amount_gens = amount_gens
        self._indivs_per_gen = indivs_per_gen
        self._total_indivs = self._amount_gens * self._indivs_per_gen
        self._create_new_chart()

    def get_experiment_condition_variable(self):
        return self._experiment_condition

    def on_cancel_button_clicked(self):
        logger.debug('{0} [CANCEL_BUTTON] - Executing on_cancel_button_clicked function'.format(self._log_prefix))
        self._experiment_condition.stop_experiment()

        response = QMessageBox.information(self, "Experiment Stopped",
                                           "Do you want to stop the current experiment?",
                                           QMessageBox.Yes | QMessageBox.No,
                                           QMessageBox.No)

        if response == QMessageBox.Yes:

            self._experiment_condition.cancel_experiment()
            # Set the MainWindow to invisible to not see the it after press 'Yes'
            self.setVisible(False)
            return True
        else:
            self._experiment_condition.continue_experiment()
            return False

    def _update_dialog(self, indivs_per_gen_counter, total_indivs_counter, gen_counter, cost):
        logger.debug('{0} [UPDATE_EXP_IN_PROGRESS] - Executing update_dialog function'.format(self._log_prefix))
        indiv_progress_bar = self._autogenerated_object.indiv_progress_bar
        gen_progress_bar = self._autogenerated_object.gen_progress_bar
        indiv_label = self._autogenerated_object.indiv_label
        gen_label = self._autogenerated_object.gen_label

        indiv_progress_bar.setValue(int(float(indivs_per_gen_counter) / self._indivs_per_gen * 100))
        indiv_progress_bar.valueChanged.emit(int(float(indivs_per_gen_counter) / self._indivs_per_gen * 100))
        gen_progress_bar.setValue(int(float(total_indivs_counter) / self._total_indivs * 100))
        gen_progress_bar.valueChanged.emit(int(float(total_indivs_counter) / self._total_indivs * 100))

        self._current_generation = self._from_gen + gen_counter
        gen_label.setText("<b>Generation {0}/{1}</b>".format(self._current_generation, self._to_gen))
        indiv_label.setText("<b>Individual {0}/{1}</b>".format(indivs_per_gen_counter, self._indivs_per_gen))
        self._update_current_gen_experiment(indivs_per_gen_counter, cost)

    def _simulation_finished(self):
        logger.debug('{0} [SIM_FINISHED] - Executing _simulation_finished function'.format(self._log_prefix))
        self._simulation_has_finished = True
        # Set the MainWindow to invisible to not see the it after press 'Yes'
        self.setVisible(False)

        self._parent_signal.emit(self._experiment_condition.experiment_cancelled(),
                                 self._experiment_condition.experiment_failure())
        self.close()

    def _update_current_gen_experiment(self, indiv_index, cost):
        if cost > self._chart_params["max_cost"]:
            self._indiv_chart.append_point(1, indiv_index, self._chart_params["overflow_value"])
            return

        if math.isnan(cost) or math.isinf(cost):
            self._indiv_chart.append_point(2, indiv_index, self._chart_params["nan_value"])
            return

        self._indiv_chart.append_point(0, indiv_index, cost)

    def _create_new_chart(self):
        # Insert the widget into the widget
        picture_layout = self._autogenerated_object.picture_layout

        chart_title = 'Generation {0} - Cost Per Individual'.format(self._current_generation + 1)
        chart_font = QFont()
        chart_font.setWeight(QFont.ExtraBold)
        indiv_chart = QtChartWrapper(show_legend=True)
        indiv_chart.set_title(chart_title, chart_font)
        indiv_chart.set_object_name("indiv_chart")

        # Set the object name to be able to retrieve it later
        indiv_chart.set_xaxis(log=False, label="Individuals",
                              label_format='%i', tick_count=10)
        indiv_chart.set_yaxis(log=False, label="Costs",
                              label_format='%g', tick_count=11)
        # Blue: Valid points
        marker_size = self._chart_params["marker_size"]
        indiv_chart.add_scatter(marker_size=marker_size,
                                color=self._chart_params["valid_points_color"],
                                legend="Valid Points")
        # Red: Overflow points
        indiv_chart.add_scatter(marker_size=marker_size,
                                color=self._chart_params["overflow_color"],
                                legend="Overflow")
        # Yellow: Nan and Inf points
        indiv_chart.add_scatter(marker_size=marker_size,
                                color=self._chart_params["nan_color"],
                                legend="Nan or Inf")

        indiv_canvas = indiv_chart.get_widget()
        indiv_canvas.chart().axisX().setRange(1, self._indivs_per_gen)
        indiv_canvas.chart().axisY().setRange(self._chart_params["min_cost"],
                                              self._chart_params["max_cost"])

        # Remove all previous widgets before rendering again
        for i in reversed(range(picture_layout.count())):
            picture_layout.itemAt(i).widget().setParent(None)
        # Add the Indiv Canvas
        picture_layout.addWidget(indiv_canvas)
        self._indiv_chart = indiv_chart

    def _board_setup_failure(self, error):
        logger.debug('{0} [SIM_FINISHED] - Board setup failure: {1}'.format(self._log_prefix, error))
        selection = QMessageBox.critical(self, "Board Setup error",
                                         error,
                                         QMessageBox.Ok)
        self._experiment_condition.cancel_experiment()
        self._simulation_finished()

    def _board_io_error(self, error):
        logger.debug('{0} [SIM_FINISHED] - Board IO error: {1}'.format(self._log_prefix, error))
        selection = QMessageBox.critical(self, "Board IO error",
                                         error,
                                         QMessageBox.Ok)
        self._experiment_condition.cancel_experiment()
        self._simulation_finished()


class ExperimentInProgress(Thread):

    def __init__(self, mlc_local, experiment_name,
                 to_gen, from_gen, chart_params,
                 parent_signal, gen_creator=None,
                 parent=None):
        Thread.__init__(self)

        self._mlc_local = mlc_local
        self._experiment_name = experiment_name
        self._experiment_info = self._mlc_local.get_experiment_info(experiment_name)
        self._to_gen = to_gen

        # If the experiment was not evaluated yet, use from_gen as 0
        self._from_gen = 0
        if self._experiment_info["generations"] != 0:
            self._from_gen = from_gen

        self._log_prefix = '[EXPERIMENT_IN_PROGRESS]'
        self._callbacks = {MLC_CALLBACKS.ON_START:          self.simulation_started,
                           MLC_CALLBACKS.ON_NEW_GENERATION: self.new_generation_created,
                           MLC_CALLBACKS.ON_EVALUATE:       self.indiv_evaluated,
                           MLC_CALLBACKS.ON_FINISH:         self.simulation_finished}

        # Progress bar counters
        self._indiv_per_gen_counter = 0
        self._total_indivs_counter = 0
        self._gen_counter = 0
        self._amount_gens = to_gen - from_gen
        self._indivs_per_gen = int(self._experiment_info["individuals_per_generation"])
        self._experiment_signal = None

        self._dialog = ExperimentInProgressWindow(parent=parent,
                                                  parent_signal=parent_signal,
                                                  chart_params=chart_params,
                                                  from_gen=from_gen,
                                                  to_gen=to_gen)

        self._experiment_condition = self._dialog.get_experiment_condition_variable()
        self._dialog.add_experiment_data(self._amount_gens, self._indivs_per_gen)
        self._dialog.show()

        # Individuals to be inserted in the first generation
        self._gen_creator = gen_creator

    def run(self):
        logger.debug('{0} [RUN] - Executing Thread mainloop'.format(self._log_prefix))
        try:
            self._mlc_local.go(self._experiment_name, self._to_gen,
                               self._from_gen, self._callbacks,
                               self._gen_creator)
        except ThreadCancelException, err:
            logger.info('{0} [RUN] - Thread was cancelled by the user'
                        .format(self._log_prefix))
            self._dialog.simulation_finished.emit()
        except ProtocolSetupException, err:
            logger.info('{0} [RUN] - Error in arduino configuration'
                        .format(self._log_prefix))
            self._experiment_condition.fail_experiment()
            self._dialog.board_setup_failure.emit(str(err))
        except ProtocolIOException, err:
            logger.info('{0} [RUN] - I/O error in arduino connection'
                        .format(self._log_prefix))
            self._experiment_condition.fail_experiment()
            self._dialog.board_io_error.emit(srt(err))
        except Exception:
            logger.info('{0} [RUN] - Unknown Exception catch. Aborting experiment'
                        .format(self._log_prefix))
            traceback.print_exc()
            sys.exit(-1)

    def indiv_evaluated(self, individual_id, cost):
        logger.debug('{0} [INDIV_EV] - Executing indiv_evaluated callback. '
                     'Indiv Id: {1} - Cost: {2}'
                     .format(self._log_prefix, individual_id, cost))

        self._indiv_per_gen_counter += 1
        self._total_indivs_counter += 1
        self._dialog.indiv_evaluated.emit(self._indiv_per_gen_counter,
                                          self._total_indivs_counter,
                                          self._gen_counter,
                                          cost)
        self._check_if_project_stopped_or_cancelled()

    def new_generation_created(self, generation_number):
        logger.debug('{0} [NEW_GEN_CREATED] - '
                     'Executing new_generation_created function'
                     .format(self._log_prefix))
        self._gen_counter += 1
        self._indiv_per_gen_counter = 0
        self._dialog.new_generation.emit()
        self._check_if_project_stopped_or_cancelled()

    def simulation_started(self):
        logger.debug('{0} [SIM_STARTED] - Executing simulation_started function'.format(self._log_prefix))
        self._check_if_project_stopped_or_cancelled()

    def simulation_finished(self):
        logger.debug('{0} [SIM_FINISHED] - Executing simulation_finished function'.format(self._log_prefix))
        self._dialog.simulation_finished.emit()

    def _check_if_project_stopped_or_cancelled(self):
        self._experiment_condition.wait_if_experiment_stopped()
        # Check if the experiment was cancelled
        if self._experiment_condition.experiment_cancelled():
            logger.debug('{0} [CHECK_IF_PROJECT_CANCELLED] - Raising ThreadCancelException'
                         .format(self._log_prefix))
            raise ThreadCancelException()
